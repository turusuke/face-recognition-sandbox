{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["startVideo","video","a","constraints","audio","navigator","mediaDevices","getUserMedia","srcObject","console","error","tinyFaceDetectorOption","inputSize","scoreThreshold","interval","canvas","displaySize","faceapi","withFaceLandmarks","detectionsWithLandmarks","length","window","requestAnimationFrame","context","getContext","clearRect","width","height","resizedDetectionsWithLandmarks","drawFaceLandmarks","leftEye","landmarks","getLeftEye","rightEye","getRightEye","font","fillText","x","y","App","useEffect","document","querySelector","Promise","all","tinyFaceDetector","loadFromUri","faceLandmark68Net","addEventListener","append","className","id","autoPlay","muted","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"oWAIMA,G,MAAU,uCAAG,WAAOC,GAAP,eAAAC,EAAA,sEAETC,EAAc,CAAEC,OAAO,EAAOH,MAAO,IAF5B,SAGSI,UAAUC,aAAaC,aAAaJ,GAH7C,OAGfF,EAAMO,UAHS,uDAKfC,QAAQC,MAAR,MALe,yDAAH,uDASVC,EAAyB,CAC7BC,UAAW,IACXC,eAAgB,I,SAGHC,E,kFAAf,WAAwBb,EAAyBc,EAA2BC,GAA5E,uBAAAd,EAAA,sEACwCe,IAElChB,EACA,IAAIgB,IAAgCN,IAErCO,oBANL,aACQC,EADR,QAQ8BC,QAAU,GARxC,yCASWC,OAAOC,uBAAsB,kBAAMR,EAASb,EAAOc,EAAQC,OATtE,UAWQO,EAAUR,EAAOS,WAAW,MAXpC,iDAaED,EAAQE,UAAU,EAAG,EAAGV,EAAOW,MAAOX,EAAOY,QAEvCC,EAAiCX,IACrCE,EACAH,GAEFC,IAAaY,kBAAkBd,EAAQa,GACjCE,EAAUF,EAA+B,GAAGG,UAAUC,aAAa,GACnEC,EAAWL,EAA+B,GAAGG,UAAUG,cAAc,GAC3EX,EAAQY,KAAO,aACfZ,EAAQa,SAAS,SAAKN,EAAQO,EAAGP,EAAQQ,EAAI,IAC7Cf,EAAQa,SAAS,SAAKH,EAASI,EAAGJ,EAASK,EAAI,IAC/CjB,OAAOC,uBAAsB,kBAAMR,EAASb,EAAOc,EAAQC,MAzB7D,6C,sBAyDeuB,MA7Bf,WAoBE,OAnBAC,qBAAU,WACR,IAAMvC,EAAQwC,SAASC,cAAc,SAChCzC,GACL,sBAAC,sBAAAC,EAAA,sEACOyC,QAAQC,IAAI,CAChB5C,EAAWC,GACXgB,IAAa4B,iBAAiBC,YAAY,oCAC1C7B,IAAa8B,kBAAkBD,YAAY,sCAJ9C,OAMC7C,EAAM+C,iBAAiB,QAAQ,WAAO,IAAD,EAC7BjC,EAASE,IAA8BhB,GAC7C,UAAAwC,SAASC,cAAc,eAAvB,SAAgCO,OAAOlC,GACvC,IAAMC,EAAc,CAAEU,MAAOzB,EAAMyB,MAAOC,OAAQ1B,EAAM0B,QACxDV,IAAwBF,EAAQC,GAChCK,OAAOC,uBAAsB,kBAAMR,EAASb,EAAOc,EAAQC,SAX9D,0CAAD,MAiBA,yBAAKkC,UAAU,OACb,8BACE,2BAAOC,GAAG,QAAQzB,MAAM,MAAMC,OAAO,MAAMyB,UAAQ,EAACC,OAAK,OCzD7CC,QACW,cAA7BjC,OAAOkC,SAASC,UAEe,UAA7BnC,OAAOkC,SAASC,UAEhBnC,OAAOkC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFnB,SAASoB,eAAe,SDiIpB,kBAAmBxD,WACrBA,UAAUyD,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAzD,GACLD,QAAQC,MAAMA,EAAM0D,c","file":"static/js/main.e238ce0f.chunk.js","sourcesContent":["import React, { useEffect } from \"react\";\nimport * as faceapi from \"face-api.js\";\nimport \"./App.css\";\n\nconst startVideo = async (video: HTMLVideoElement) => {\n  try {\n    const constraints = { audio: false, video: {} };\n    video.srcObject = await navigator.mediaDevices.getUserMedia(constraints);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nconst tinyFaceDetectorOption = {\n  inputSize: 224,\n  scoreThreshold: 0.5\n};\n\nasync function interval(video: HTMLVideoElement, canvas: HTMLCanvasElement, displaySize: faceapi.IDimensions) :Promise<undefined | number>{\n  const detectionsWithLandmarks = await faceapi\n    .detectAllFaces(\n      video,\n      new faceapi.TinyFaceDetectorOptions(tinyFaceDetectorOption)\n    )\n    .withFaceLandmarks();\n\n  if (detectionsWithLandmarks.length <= 0)\n    return window.requestAnimationFrame(() => interval(video, canvas, displaySize));\n\n  const context = canvas.getContext(\"2d\");\n  if(!context) return;\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  const resizedDetectionsWithLandmarks = faceapi.resizeResults(\n    detectionsWithLandmarks,\n    displaySize\n  );\n  faceapi.draw.drawFaceLandmarks(canvas, resizedDetectionsWithLandmarks);\n  const leftEye = resizedDetectionsWithLandmarks[0].landmarks.getLeftEye()[1];\n  const rightEye = resizedDetectionsWithLandmarks[0].landmarks.getRightEye()[1];\n  context.font = \"40px serif\";\n  context.fillText(\"ほ\", leftEye.x, leftEye.y + 10);\n  context.fillText(\"げ\", rightEye.x, rightEye.y + 10);\n  window.requestAnimationFrame(() => interval(video, canvas, displaySize));\n}\n\nfunction App() {\n  useEffect(() => {\n    const video = document.querySelector(\"video\");\n    if (!video) return;\n    (async () => {\n      await Promise.all([\n        startVideo(video),\n        faceapi.nets.tinyFaceDetector.loadFromUri(\"/face-recognition-sandbox/models\"),\n        faceapi.nets.faceLandmark68Net.loadFromUri(\"/face-recognition-sandbox/models\")]);\n\n      video.addEventListener(\"play\", () => {\n        const canvas = faceapi.createCanvasFromMedia(video);\n        document.querySelector(\"main\")?.append(canvas);\n        const displaySize = { width: video.width, height: video.height };\n        faceapi.matchDimensions(canvas, displaySize);\n        window.requestAnimationFrame(() => interval(video, canvas, displaySize));\n      });\n    })();\n  });\n\n  return (\n    <div className=\"App\">\n      <main>\n        <video id=\"video\" width=\"720\" height=\"560\" autoPlay muted/>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}